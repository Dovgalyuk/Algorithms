\documentclass[10pt,twoside,openany]{book}

\include{preamble}

\begin{document}

\include{title}
\include{titleback}

\tableofcontents

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Строки
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Строки}

\section{Изограммы}

Изограмма --- это слово (или фраза), в котором не повторяются буквы.

Напишите программу, которая проверяет, является ли введённая строка изограммой.
Строка состоит из множества латинских букв в разном регистре, пробелов и знаков препинания.
Причём в изограмме пробелы или знаки препинания могут повторяться.

При реализации используйте следующие конструкции:
\begin{itemize}
    \item Функцию {\tt std::isalpha}
    \item Функцию {\tt std::tolower} или {\tt std::toupper}
\end{itemize}

\subsection*{Контрольные вопросы}

В вопросах подразумевается, что для входных данных используется кодировка ASCII.

\begin{itemize}
    \item Какой фрагмент кода мог бы заменить функцию {\tt std::isalpha}?
    \item Как можно реализовать функцию {\tt std::tolower}?
\end{itemize}

\section{Боб}

Боб не очень любит разговаривать, поэтому использует небольшой набор реплик.

Он отвечает <<Sure.>> на любой вопрос, например <<How are you?>>.

Он говорит <<Whoa, chill out!>>, если вы КРИЧИТЕ НА НЕГО (то есть используете одни заглавные буквы).

Он отвечает <<Calm down, I know what I'm doing!>> на вопрос, в котором вы кричите.

Он говорит <<Fine. Be that way!>> если вы обращаетесь к нему, но ничего
не говорите (это значит, что входная строка программы состоит из пробельных символов).

Он говорит <<Whatever.>> во всех остальных случаях.

Напишите диалоговую программу, которая имитирует разговор с Бобом. На каждую входную строку она
должна выводить такой ответ, какой давал бы Боб в такой же ситуации. Входные реплики для программы
должны подчиняться правилам пунктуации английского языка.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Каким способом проверяется, что все буквы во введённой строке заглавные?
    \item Какую функцию стандартной библиотеки можно использовать для проверки пробельных символов?
\end{itemize}

\section{Шифровальный квадрат}

Реализуйте описанный ниже алгоритм шифрования текста. На вход ваша программа
будет получать текст на английском языке, а на выходе должна быть зашифрованная
версия этого текста.

При шифровании удаляются все знаки препинания и пробелы, а буквы приводятся к нижнему регистру.

Затем нормализованный таким образом текст разбивается на строки.
Эти строки можно выстроить в виде прямоугольника.

Например, предложение <<If man was meant to stay on the ground, god would have given us roots.>>
нормализуется в виде:

\begin{verbatim}
ifmanwasmeanttostayonthegroundgodwouldhavegivenusroots
\end{verbatim}

Полученный текст перестраивается в виде прямоугольника размером в $r$~строк и $c$~столбцов,
причём $c \geq r$ и $c - r \leq 1$.

Таким образом, текст из примера выше должен быть преобразован в следующий прямоугольник
из $8$ столбцов и $7$ строк:

\begin{verbatim}
"ifmanwas"
"meanttos"
"tayonthe"
"groundgo"
"dwouldha"
"vegivenu"
"sroots  "
\end{verbatim}

Закодированное сообщения получается чтением сверху вниз всех столбцов от левого до правого.
Для нашего примера получится следующий шифр:

\begin{verbatim}
imtgdvsfearwermayoogoanouuiontnnlvtwttddesaohghnsseoau
\end{verbatim}

Выведите полученный текст фрагментами, разделяя их пробелами.
Всего должно быть $c$~фрагментов длиной $r$.
Если для заполнения прямоугольника $r\times c$ не хватает $n$ символов,
дополните каждый из $n$ последних фрагментов одним пробелом в конце, вот так:

\begin{verbatim}
"imtgdvs fearwer mayoogo anouuio ntnnlvt wttddes aohghn  sseoau "
\end{verbatim}

Если снова расположить эти фрагменты в прямоугольнике, их можно аналогичным образом расшифровать:

\begin{verbatim}
"imtgdvs"
"fearwer"
"mayoogo"
"anouuio"
"ntnnlvt"
"wttddes"
"aohghn "
"sseoau "
\end{verbatim}

\subsection*{Рекомендации к заданию}

При написании программы попробуйте обойтись без дополнительной структуры данных, в которой
хранился бы прямоугольник.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Какой максимальный объём текста может зашифровать ваша программа за один раз?
    \item Как хранится в памяти прямоугольник, который выводится на экран?
    \item В каком порядке обрабатываются символы нормализованной строки для вывода прямоугольника?
\end{itemize}

\section{Подстроки}

На входе в программу поступает строка из цифр и число $n$. Программа должна вывести все
непрерывные подстроки исходной строки длины $n$.

Например, для строки $49142$ и $n=3$ вывод будет таким: $491$, $914$, $142$.

А для $n=4$ таким: $4914$, $9142$.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Какую стандартную функцию можно использовать для получения подстрок?
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% array
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{std::array}

\section{Массивы-значения}
\label{array-value}

Сравните две программы ниже. Предположите, какие значения выводятся в каждой из них,
а затем попробуйте запустить их и проверить результат.

\lstinputlisting{sources/array1.cpp}

\lstinputlisting{sources/array2.cpp}

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Что выведут первая и вторая программы?
    \item Как можно было бы доработать вторую, чтобы получался такой же результат, как и в первой?
    \item Какое преимущество даёт использование {\tt std::array}?
    \item Что нужно изменить, чтобы не переделывать функцию {\tt sum} при изменении размера массива?
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% vector
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{std::vector}

\section{new[]/delete[] vs std::vector}

Перепишите следующую программу, используя {\tt std::vector}.

Последовательно избавьтесь от следующих конструкций:
\begin{itemize}
    \item Операторы {\tt new[]/delete[]} (переменные {\tt a} и {\tt b}
          превратите в объекты {\tt std::vector}.
    \item Переменная {\tt m} и цикл для вычисления её значения.
\end{itemize}

\lstinputlisting{sources/vector1.cpp}

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Что делает исходная программа?
    \item Какие ограничения неявно наложены на значение переменной {\tt n}?
    \item На сколько строк удалось сократить исходный код, используя {\tt std::vector}?
    \item Когда освобождается память, используемая {\tt std::vector}?
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% list
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{std::list}

\section{Список вместо массива}

Проанализируйте следующую программу. Попробуйте выяснить, как время её работы растёт
с увеличением входного параметра $n$.

\lstinputlisting{sources/list1.cpp}

Перепишите программу с использованием контейнера {\tt std::list} вместо массива.
Для вставки значений в список используйте функцию {\tt std::list::insert}.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item В чём заключается ошибка программиста, который написал исходную программу?
    \item Какими способами можно просмотреть все элементы списка, чтобы вывести их на экран?
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Алгоритмы
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Алгоритмы}

\section{std::accumulate}

Переделайте функции {\tt sum} в программах из задания~\ref{array-value},
используя алгоритм {\tt std::accumulate}.
Для этого потребуется подключить заголовочный файл {\tt numeric}.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Как переделать вызов {\tt std::accumulate}, чтобы вычислялась сумма элементов
          из первой половины массива?
\end{itemize}

\section{Снова std::accumulate}

Переделайте программы из предыдущего задания, чтобы вместо суммы функция {\tt std::accumulate} считала
произведение элементов.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Какое значение должно получиться, если в массиве не будет ни одного элемента?
\end{itemize}

\section{Сортировка}

Напишите программу, которая вводит с клавиатуры последовательность чисел. Длина последовательности
тоже задаётся пользователем. Затем реализуйте свой любимый алгоритм сортировки для
того, чтобы упорядочить эту последовательность по возрастанию.

Ваша программа не должна ограничивать длину последовательности размером используемой
структуры данных для её хранения.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Какой алгоритм сортировки вы применили?
    \item Можно ли этим алгоритмом отсоритировать за разумное время последовательность
          из $1000000$ элементов?
    \item Как изменить порядок сортировки в вашей программе?
\end{itemize}

\section{std::sort}

Замените сортировку из программы для предыдущего задания на функцию {\tt std::sort}
из стандартной библиотеки. Для этого понадобится заголовочный файл {\tt algorithm}.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Какое хранилище использовалось для исходной последовательности в вашей программе?
    \item Как можно задать желаемый порядок элементов в результате сортировки?
\end{itemize}

\section{Двоичный поиск в массиве}

Ещё раз доработайте предыдущую программу. Пусть она запрашивает несколько чисел, которые нужно
поискать в массиве. Для каждого нужно вывести нашлось оно или нет.

Сравните скорость работы вашего алгоритма поиска и стандартной функции
{\tt std::binary\_search}.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Сколько итераций цикла может выполнить двоичный поиск для массива
          из $10$~элементов?
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Структуры данных
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Структуры данных}

\section{Двоичное дерево}

Напишите программу, которая выводит на экран графическое представление двоичного дерева.
Дерево состоит из $N$ вершин, пронумерованных от $1$ до $N$.

На вход программы кроме числа $N$ поступает также информация о структуре дерева
в виде последовательности пар чисел, кодирующих связи.
В каждой паре первое число обозначает номер предка, а второе --- номер связанного с ним потомка.

Дерево нужно вывести, обозначая вершины соответствующими числами, а связи с помощью символов
<<прямой слэш>> и <<обратный слэш>>.

Пример вывода дерева:
\begin{verbatim}
      4
    /   \
   /     \
  2       6
 / \     / \
1   3   5   7
\end{verbatim}

Это дерево может быть закодировано с помощью следующих входных данных:
\begin{verbatim}
7
4 2
4 6
2 1
6 5
2 3
6 7
\end{verbatim}

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Что такое двоичное дерево?
    \item Как хранится в вашей программе двоичное дерево?
\end{itemize}

\section{Двоичное дерево поиска}

Доработайте предыдущую программу, чтобы она проверяла, является ли дерево из входных
данных двоичным деревом поиска.

В двоичном дереве поиска узлы упорядочены таким образом, что значение любого левого потомка
меньше, чем значение корня, а значение любого правого потомка больше, чем корень.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Какая может быть максимальная высота двоичного дерева поиска из $N$ вершин?
\end{itemize}

\section{Двоичный поиск в дереве}

Ещё раз доработайте программу из предыдущего задания.
Теперь на вход поступают двоичное дерево поиск и последовательность чисел, которую надо в нём
найти.

Для каждого числа во входной последовательности выведите путь до него в двоичном дереве.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Сохраняет ли программа в памяти путь, который будет выводиться?
\end{itemize}

\section{Кольцевой буфер}

Реализуйте кольцевой буфер с использованием статического массива или контейнеров
{\tt std::array} и {\tt std::vector}.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Можно ли использовать все возможные ячейки в памяти, используемой под буфер?
    \item Какую абстрактную структуру данных можно реализовать с помощью
          кольцевого буфера?
\end{itemize}

\chapter{Хеширование}

\section{Анаграммы}

Анаграмма --- это слово, полученное из исходного перестановкой букв.
Напишите программу, которая определяет, какие слова из списка являются анаграммами
заданного слова.

Например, для слова <<listen>> и списка <<enlists>>, <<google>>, <<inlets>>, <<banana>>
программа должна вывести список из одного элемента: <<inlets>>.

Предварительный отсев слов-кандидатов выполняйте с помощью вычисления
хеш-функции от этих строк.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Какую хеш-функцию вы выбрали?
    \item Можно ли для тех же целей использовать стандартную
          реализацию {\tt std::hash<std::string>}?
    \item Что кроме хеш-функции нужно использовать, чтобы убедиться, что буквы в строках совпадают?
\end{itemize}

\section{Коллизии}

Найти все анаграммы из слов-кандидатов для всех подмножеств букв из исходного слова.

Получить подмножества букв можно несколькими способами:
\begin{itemize}
    \item Рекурсивный перебор. На каждом шаге обрабатывается одна буква входного слова.
          Для каждого варианта (когда буква включается в результирующее слово и когда не включается)
          рекурсивный поиск продолжается со следующей буквой.
    \item Последовательно увеличивающиеся целые числа можно раскладывать на двоичные разряды.
          Каждый разряд сопоставляется одной букве. Если разряд $1$, то буква включается
          в результирующее подмножество.
\end{itemize}

Для хранения списка слов-кандидатов используйте контейнер {\tt std::unordered\_set}.
Этот контейнер использует хеширование для поиска и упорядочивания элементов.
Используйте второй параметр шаблона контейнера для указания собственной хеш-функции,
чтобы сравнивать строки без учёта порядка букв.
После генерации очередного подмножества букв можно проверять, если ли уже слово с такими
буквами в контейнере.

Проанализируйте, как часто возникают коллизии, если использовать только хеширование,
без сложной функции сравнения строк.

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item С чем связано, что строки из разных букв могут получать одни и те же значения
          хеш-функции?
    \item Приведите пример двух строк из разных букв, но с одинаковым значением хеш-функции.
\end{itemize}

\chapter{std::map}

\section{Поиск}

Перепишите следующую программу, используя {\tt std::map}.

Выполните следующие действия:
\begin{itemize}
    \item Замените массивы {\tt word} и {\tt def} на переменную-контейнер {\tt std::map}.
    \item Замените алгоритм поиска на функцию {\tt find} контейнера {\tt std::map}.
\end{itemize}

\lstinputlisting{sources/map1.cpp}

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Что делает исходная программа?
    \item Какой тип ключа применяется в использованном контейнере {\tt std::map}?
    \item Что возвращает функция {\tt find}, если нужный элемент не найден?
\end{itemize}

\section{Подсчёт слов}

Напишите программу, которая выводит сколько раз каждое слово из входной строки повторяется в ней.

Слова могут состоять из цифр и латинских букв. Слова с разным регистром букв считаются одинаковыми.
Знаки препинания, пробелы, переносы строк и символы табуляции нужно игнорировать.

\subsection*{Подзадачи}

\begin{itemize}
    \item Используйте {\tt std::map<std::string, int>} для хранения информации о количестве повторов.
    \item Попробуйте не считывать весь текст целиком, а читать по одному символу из входного потока.
    \item Напишите два варианта программы: с преобразованием хранимых в {\tt std::map} слов и без него.
          Для второго варианта замените функцию сравнения (третий параметр шаблона) на собственную.
\end{itemize}

\subsection*{Контрольные вопросы}

\begin{itemize}
    \item Определён ли порядок элементов в {\tt std::map}? Можно ли его изменить?
\end{itemize}

\end{document}
