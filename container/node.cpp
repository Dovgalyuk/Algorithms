#include <iostream>

#include "node.h"

using namespace std;

//Добавление узла в дерево
struct Node *addNode(Node *tree, string *str) {
	if (tree == NULL) {								//Если узла нет, то создаем новый узел со строкой str
		tree = (Node*)malloc(sizeof(Node));
		tree->key = str;
		tree->left = NULL;
		tree->right = NULL;
		tree->height = 1;
	}
	else {
		if (str < tree->key) {						//Если строка меньше текущего узла, то идём влево
			tree->left = addNode(tree->left, str);
		}
		else if (str > tree->key) {					//Если строка больше текущего узла, то идём вправо
			tree->right = addNode(tree->right, str);
		}
	}
	return balanceAVLTree(tree);					//Делаем балансировку
}

//Поиск узла
bool findNode(Node *tree, string *str) {
	if (tree != NULL)
	{
		if (str == tree->key) {
			return true;
		}
		if (findNode(tree->left, str) == true) {
			return true;
		}
		if (findNode(tree->right, str) == true) {
			return true;
		}
	}
	return false;
}

//Удаление узла
struct Node *deleteNode(Node *tree, string *str) {
	if (tree != NULL)
	{
		if (tree == NULL) {
			return false;
		}
		if (str < tree->key) {								//Если строка меньше текущего узла, то идём влево
			tree->left = deleteNode(tree->left, str);
		}
		else if (str > tree->key) {							//Если строка больше текущего узла, то идём вправо
			tree->right = deleteNode(tree->right, str);
		}
		else {												//Если строка равно текущему узлу(найдена), то удаляем
			Node *leftNode = tree->left;
			Node *rightNode = tree->right;
			if (rightNode == NULL) {
				return leftNode;
			}

			Node *minNode = findMinNode(rightNode);
			minNode->right = deleteMinNode(rightNode);
			minNode->left = leftNode;
			return balanceAVLTree(minNode);
		}
	}
	return false;
}

//Поиск узла с минимальным ключом
Node* findMinNode(Node * tree)
{
	if (tree->left) {
		return findMinNode(tree->left);
	}
	else {
		return tree;
	}
}

//Удаление узла с минимальным ключом
Node* deleteMinNode(Node * tree)
{
	if (tree->left == NULL)
		return tree->right;
	tree->left = deleteMinNode(tree->left);
	return balanceAVLTree(tree);
}

//Балансировка дерева
Node* balanceAVLTree(Node* node)
{
	countHeight(node);
	if (balanceTree(node) == 2)						//Если баланс равен 2, то делаем балансировку
	{
		if (balanceTree(node->right) < 0)
			node->right = turnRight(node->right);
		return turnLeft(node);
	}
	if (balanceTree(node) == -2)					//Если баланс равен -2, то делаем балансировку
	{
		if (balanceTree(node->left) > 0)
			node->left = turnLeft(node->left);
		return turnRight(node);
	}
	balanceTree(node);
	return node;
}

//Высота узла
unsigned char height(Node* node)
{
	if (node != NULL) {
		return node->height;
	}
	else {
		return 0;
	}
}

//Подсчет высоты узлов дерева
void countHeight(Node* node)
{
	unsigned char heightLeft = height(node->left);
	unsigned char heightRight = height(node->right);
	if (heightLeft > heightRight) {
		node->height = heightLeft + 1;
	}
	else {
		node->height = heightRight + 1;
	}
}

//Баланс дерева
int balanceTree(Node* node)
{
	return height(node->right) - height(node->left);
}

//Левый поворот
Node* turnLeft(Node* leftNode)
{
	Node* rightNode = leftNode->right;
	leftNode->right = rightNode->left;
	rightNode->left = leftNode;
	countHeight(leftNode);
	countHeight(rightNode);
	return rightNode;
}

//Правый поворот
Node* turnRight(Node* rightNode)
{
	Node* leftNode = rightNode->left;
	rightNode->left = leftNode->right;
	leftNode->right = rightNode;
	countHeight(rightNode);
	countHeight(leftNode);
	return leftNode;
}