#ifndef QUEUE_H
#define QUEUE_H

#include <stack>
using namespace std;

//Реализация очереди с помощью двух модулей stack
class queue {
private:
	stack<char> s1;	//Стек s1
	stack<char> s2;	//Стек s2

public:
	//Метод добавления элемента в очередь
	void push(int n)
	{
		while (!s2.empty())	//Пока стек s2 не будет пустым...
		{
			s1.push(s2.top());	//...вставляем элемент из s2 в s1...
			s2.pop();			//...и удаляем данный элемент в s2
		}
		s1.push(n);	//Вставляем новый элемент в s2
	}

	//Метод удаления первого элемента из очереди
	void pop()
	{
		while (!s1.empty())	//Пока стек s1 не будет пустым...
		{
			s2.push(s1.top());	//...вставляем элемент из s1 в s2...
			s1.pop();			//...и удаляем данный элемент в s2
		}
		s2.pop();	//Удаляем первый элемент
		//Возвращаем все элементы в 1 стек
		while (!s2.empty())	//Пока стек s2 не будет пустым...
		{
			s1.push(s2.top());	//...вставляем элемент из s2 в s1...
			s2.pop();			//...и удаляем данный элемент в s2
		}
	}

	//Получение значения первого элемента
	int front() {
		int frontElem;
		while (!s1.empty())	//Пока стек s1 не будет пустым...
		{
			s2.push(s1.top());	//...вставляем элемент из s1 в s2...
			s1.pop();			//...и удаляем данный элемент в s2
		}
		}
		frontElem = s2.top();	//Получаем значение первого элемента
		//Возвращаем все элементы в 1 стек
		while (!s2.empty())	//Пока стек s2 не будет пустым...
		{
			s1.push(s2.top());	//...вставляем элемент из s2 в s1...
			s2.pop();			//...и удаляем данный элемент в s2
		}
		return frontElem;
	}

	//Обращение к последнему элементу
	int back() {
		return s1.top();	//Получаем значение последнего элемента
	}

	//Проверка очереди на пустоту
	bool empty() {
		if (s1.empty())
			return true;
		else
			return false;
	}
};

#endif
